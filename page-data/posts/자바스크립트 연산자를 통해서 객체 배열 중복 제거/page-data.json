{"componentChunkName":"component---src-templates-post-template-jsx","path":"/posts/자바스크립트 연산자를 통해서 객체 배열 중복 제거/","result":{"data":{"markdownRemark":{"html":"<p>js 연산자 ?? ?, &#x26;&#x26; ||</p>\n<ol start=\"4\">\n<li>객체의 특정 속성만 비교해서 중복제거</li>\n</ol>\n<p>다음과 같은 객체의 배열이 있다고 가정해 보겠습니다:</p>\n<p>const members = [\r\n{ id: 1, name: ‘John’ },\r\n{ id: 2, name: ‘Jane’ },\r\n{ id: 1, name: ‘Johnny’ },\r\n{ id: 4, name: ‘Alice’ },\r\n];\r\n첫 번째 요소의 id는 세 번째 요소와 동일합니다. 이러한 목록에서 중복을 제거하려면 다음과 같이 할 수 있습니다:</p>\n<p>const unique = […new Map(members.map((m) => [m.id, m])).values()];\r\nconsole.log(unique);\r\n위의 코드가 작동되는 방법은 먼저 map() 메소드를 사용하여 원래 배열에서 새 배열을 만듭니다:</p>\n<p>members.map((m) => [m.id, m])\r\n이는 배열의 배열을 리턴합니다. 중첩된 각 배열에는 id와 해당 객체의 값이 포함됩니다:</p>\n<p>const members = [\r\n{ id: 1, name: ‘John’ },\r\n{ id: 2, name: ‘Jane’ },\r\n{ id: 1, name: ‘Johnny’ },\r\n{ id: 4, name: ‘Alice’ },\r\n];</p>\n<p>-> members.map(m => [m.id, m])\r\n[\r\n[ 1, { id: 1, name: ‘John’ } ],\r\n[ 2, { id: 2, name: ‘Jane’ } ],\r\n[ 1, { id: 1, name: ‘Johnny’ } ],\r\n[ 4, { id: 4, name: ‘Alice’ } ]\r\n]\r\n다음으로 Map() 객체를 생성하여 중복을 제거하는 것 입니다:</p>\n<p>const newMap = new Map(members.map(m => [m.id, m]));\r\nconsole.log(newMap);\r\n위 코드의 실행 결과는:</p>\n<p>Map(3) {\r\n1 => { id: 1, name: ‘Johnny’ },\r\n2 => { id: 2, name: ‘Jane’ },\r\n4 => { id: 4, name: ‘Alice’ }\r\n}\r\nMap 객체의 키는 고유해야 하므로 배열의 배열에서 Map을 생성하면 키 당 중복된 객체(이 경우 id)는 제거됩니다.</p>\n<p>세 번째로 values() 메소드를 호출하여 Map의 iterator를 가져옵니다:</p>\n<p>const iterator = newMap.values();\r\nconsole.log(iterator);</p>\n<p>// [Map Iterator] {\r\n//   { id: 1, name: ‘Johnny’ },\r\n//   { id: 2, name: ‘Jane’ },\r\n//   { id: 4, name: ‘Alice’ }\r\n// }\r\n마지막으로 스프레드 연산자(…)를 사용해 iterator를 배열로 변환합니다:</p>\n<p>const uniqueMembers = […iterator];\r\nconsole.log(uniqueMembers);</p>\n<p>// [\r\n//   { id: 1, name: ‘Johnny’ },\r\n//   { id: 2, name: ‘Jane’ },\r\n//   { id: 4, name: ‘Alice’ }\r\n// ]\r\n전체 코드를 보면:</p>\n<p>const members = [\r\n{ id: 1, name: ‘John’ },\r\n{ id: 2, name: ‘Jane’ },\r\n{ id: 1, name: ‘Johnny’ },\r\n{ id: 4, name: ‘Alice’ },\r\n];</p>\n<p>const newArray = members.map((m) => [m.id, m]);\r\nconst newMap = new Map(newArray);\r\nconst iterator = newMap.values();\r\nconst unique = […iterator];</p>\n<p>console.log(unique);\r\n여기서 다음 네 줄의 코드를:</p>\n<p>const newArray = members.map((m) => [m.id, m]);\r\nconst newMap = new Map(newArray);\r\nconst iterator = newMap.values();\r\nconst unique = […iterator];\r\n다음과 같이 축약할 수 있습니다:</p>\n<p>const unique = […new Map(members.map((m) => [m.id, m])).values()];\r\n이를 적용하면:</p>\n<p>const members = [\r\n{ id: 1, name: ‘John’ },\r\n{ id: 2, name: ‘Jane’ },\r\n{ id: 1, name: ‘Johnny’ },\r\n{ id: 4, name: ‘Alice’ },\r\n];</p>\n<p>const unique = […new Map(members.map((m) => [m.id, m])).values()];</p>\n<p>console.log(unique);\r\n다음의 uniqueBy() 함수는 객체의 배열과 검색할 속성 키를 받아 고유한 값만 리턴합니다:</p>\n<p>const uniqueBy = (arr, prop) => {\r\nreturn […new Map(arr.map((m) => [m[prop], m])).values()];\r\n};\r\n예를 들면 uniqueBy() 함수를 사용해 다음과 같이 중복을 제거할 수 있습니다:</p>\n<p>const members = [\r\n{ id: 1, name: ‘John’ },\r\n{ id: 2, name: ‘Jane’ },\r\n{ id: 1, name: ‘Johnny’ },\r\n{ id: 4, name: ‘Alice’ },\r\n];</p>\n<p>const uniqueBy = (arr, prop) => {\r\nreturn […new Map(arr.map((m) => [m[prop], m])).values()];\r\n};</p>\n<p>console.log(uniqueBy(members, ‘id’));</p>\n<h2 id=\"블로그\" style=\"position:relative;\"><a href=\"#%EB%B8%94%EB%A1%9C%EA%B7%B8\" aria-label=\"블로그 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>블로그</h2>\n<ol>\n<li>합성 컴포넌트 패턴(Compound Components Pattern)</li>\n<li>VAC 패턴</li>\n<li>Container - Presenter 패턴</li>\n<li>Custom Hook Pattern</li>\n<li>FLEX 패턴</li>\n<li>Folder 아키텍처</li>\n<li>옵저버 패턴</li>\n<li>MVVM 패턴</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> React <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 이거 쓰는 이유가 뭘까?</span>\r\n\r\nbox<span class=\"token operator\">-</span>sizing<span class=\"token operator\">:</span> border<span class=\"token operator\">-</span>box<span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token comment\">/* \r\n    margin - auto 를 활용한 정렬\r\n    부모 : display - flex ( 크기 지정되어있어야 한다.)\r\n    자식 : margin : auto 적용하면 최하단 또는 최상단 유지\r\n*/</span></code></pre></div>","tableOfContents":"<ul>\n<li><a href=\"#%EB%B8%94%EB%A1%9C%EA%B7%B8\">블로그</a></li>\n</ul>","frontmatter":{"title":"자바스크립트 연산자를 통해서 객체 배열 중복 제거","category":"","created":"2023-08-17"}}},"pageContext":{"id":"90c4aca0-39e3-5590-af59-94231d7d5d50"}},"staticQueryHashes":[],"slicesMap":{}}