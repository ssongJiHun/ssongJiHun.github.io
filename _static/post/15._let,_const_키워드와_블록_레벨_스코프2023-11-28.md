---
template : "post"
title : "15. let, const 키워드와 블록 레벨 스코프"
category : ""
tags : "DeepDive"
created: "2023-11-28"
---

## 참조 에러(ReferenceError) 종류


이번 정리에서는 `var` `let` `const` 키워드의 차이점에서 호이스팅 차이점을 정리하는 과정에서 참조 에러에 대해 이해하기 위해서는 참조 오류의 종류를 알고 있어야 한다고 생각해 먼저 정리했다.


### ReferenceError : ‘’ is not defined


```javascript
// 변수 선언이 없는 상황.
console.lo(foo); // ReferenceError: foo is not defined
```


**not defined** 참조 에러는 선언된 변수가 없다는 것을 의미하고 선언된 변수가 없으니 호이스팅도 발생되지 않았다는 것을 의미한다.


### ReferenceError : Cannot access ‘’  before initialization


```javascript
// **일시적 사각 지대(TDZ)
console.log(foo);** // ReferenceError: Cannot access 'foo' before initialization
**let foo = 10;**
```


**before initialization** 참조 에러는 런타임 이전 자바스크립트 엔진이 암묵적으로 “선언 단계”를 진행했다는 것을 의미한다. 
`let` `const` 키워드로 선언된 변수의 선언문 이전에 변수를 참조했을 때 발생되는 참조 에러이다.


## var 키워드로 선언한 변수의 문제점


### 변수 중복 선언 허용


`var` 키워드로 선언한 변수는 중복 선언이 가능하다.


```javascript
var x = 1;

// 초기화문이 있는 변수 선언은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작한다.
var x = 100;  // 초기화 문

// 초기화문이 없는 변수 선언은 무시된다.
var x;
```


`var` 키워드로 선언한 변수를 중복 선언하면 초기화문이 있는 변수는 자바스크립트 엔진에 의해 `var` 키워드가 없는 것 처럼 동작하고, 초기화문이 없는 변수 선언문은 무시 된다.


에러는 발생되지 않는다.


### 함수 레벨 스코프


`var` 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다.
따라서 함수 외부에서 `var` 키워드로 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수가 된다.


### 변수 호이스팅


`var` 키워드로 변수를 선언하면 **변수 호이스팅**에 의해 변수 선언문이 **스코프의 선두**로 끌어 올려진 것처럼 **동작한다.**


`var` 키워드로 선언한 변수는 런타임 이전 자바스크립트 엔진에 의해 암묵적으로 “**선언 단계**”와 “**초기화 단계**”를 **동시에 거친다.** 



만약 **변수 선언문 이전에 변수를 참조**하는 것은 변수 **호이스팅에 의해** **에러를 발생시키지는 않고** `undefined` 를 반환한다. 이는 프로그램의 흐름상  맞지 않을뿐더러 가독성을 떨어뜨리고 오류를 발생시킬 여지를 남긴다.


## let 키워드


ES6에서 새로운 변수 선언 키워드이다.


### 변수 중복 선언 금지


`let` 키워드로 이름이 동일한 변수를 중복 선언하면 문법 에러(Syntax Error)가 발생한다.


### 블록 레벨 스코프


`let` 키워드로 선언한 변수는 **모든 코드 블록을 지역 스코프로 인정**하는 **블록 레벨 스코프**를 따른다.


따라서 동일한 이름의 전역 변수와 지역 변수는 다른 블록 레벨 스코프를 가지다. 두 개의 변수는 별개의 변수이다.


### 변수 호이스팅


`let` 키워드로 선언한 변수는 **호이스팅이 발생하지 않는 것처럼** 동작한다.


`let` 키워드로 선언한 변수는 “**선언 단계**”와 “**초기화 단계**”가 **분리되어 진행된다**.
즉, 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 선언 단계가 먼저 실행되지만 초기화 단계는 변수 선언문에 도달 했을 때 실행된다.


만약 **변수 선언문 이전에 변수를 참조**하면 참조 에러(ReferenceError)가 발생한다.
스코프 시작 지점 부터 **”초기화 단계”** 시작 지점(변수 선언문)까지 변수를 참조할 수 없는 구간을 **일시적 사각 지대(TDZ)**라고 부른다.


```javascript
// 런타임 이전에 선언 단계가 실행된다. 아직 변수 초기화가 되지 않았다.
// 초기화 이전의 일시적 사각 지대에서는 변수를 참조할 수 없다.
console.log(foo) // ReferenceError: Cannot access 'foo' before initialization

let foo;
console.log(foo); // undefind

foo = 1;
console.log(foo) // 1
```


`let` 키워드로 선언한 변수는 **호이스팅이 발생하지 않는 것처럼 보이지만 그렇지 않다.**


```javascript
let foo = 1;
{
		// 호이스팅은 스코프 단위로 작동한다.
		// 이미 지역 변수 foo 는 선언 단계가 진행되었다.
		// 일시적 사각 지대(TDZ) - 참조 에러 발생
    console.log(foo)  // ReferenceError: Cannot access 'foo' before initialization
    let foo = 2;
}
```


**before initialization 참조 에러**가 발생 했다는 것은 지역 변수 foo가 **“선언 딘계”**를 거쳤다는 것을 의미한다. 즉, `let` 키워드도 **호이스팅이 발생**한다.


## const 키워드


const 키워드는 상수를 선언하기 위해서 사용된다. 하지만 반드시 상수만을 위해 사용하지는 않는다.


### let 키워드와 공통점

- **호이스팅이 발생하지 않는 것처럼** 동작한다.
- **블록 레벨 스코프**를 가진다.
- “**선언 단계**”와 “**초기화 단계**”가 **분리되어 진행된다.**

### 선언과 초기화


`const` 키워드로 선언한 변수는 반드시 선언과 동시에 초기화를 해야 한다.
그렇지 않으면 문법 에러가 발생한다.


```javascript
const foo; // SyntaxError: Missing initializer in const declaration
```


### 재할당 금지


`const` 키워드로 선언한 변수는 재할당을 금지한다.


### 상수


변수의 상대 개념은 상수는 재할당이 금지된 변수를 말한다.


`const` 키워드로 선언한 변수에 원시 값을 할당한 경우 변수 값을 변경할 수 없다. 
변경 불가능한 값인 원시 값은 재할당 없이 변경(교체) 할 수 있는 방법이 없기 때문이다.
이러한 특징을 이용해 상수를 표현하는 데 사용하기도 한다.


### const 키워드와 객체


`const` 키워드로 선언한 변수에 객체를 할당한 경우 값을 변경할 수 있다.  
변경 가능한 값인 객체는 재할당 없이도 직접 변경이 가능하기 때문이다.


`const` 키워드는 재할당을 금지할 뿐 “불변”을 의미하지 않는다.


## var vs. let vs. const


변수 선언은 기본적으로 `const` 를 사용하고 `let` 은 재할당이 필요한 경우에 한정해 사용하는 것이 좋다. `const` 키워드를 사용하면 의도하지 않은 재할당을 방지하기 때문에 안전하다.


재할당이 필요한 경우에 한정해 `let` 키워드를 사용한다. 이때 변수의 스코프는 최대한 좁게 만든다.
일단 `const` 키워드를 사용하고, 재할당이 필요하다면 그때 `let` 키워드로 변경해도 결코 늦지 않다,

