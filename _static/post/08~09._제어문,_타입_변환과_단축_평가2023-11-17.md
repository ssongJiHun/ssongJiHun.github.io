---
template : "post"
title : "08~09. 제어문, 타입 변환과 단축 평가"
category : ""
tags : "DeepDive"
created: "2023-11-17"
---

# 08. 제어문


조건문은 주어진 조건식의 평가 결과에 따라 코드 블록을 실행을 결정한다.

- `if…else` 문은 **불리언 값**으로 평가 한다.
- `switch` 문은 **문자열이나 숫자 값**으로 평가하는 경우가 많다.
- `for` `while` 문(반복문)은 **불리언 값**으로 평가하고 거짓이 될 때까지 코드 블록을 반복한다.

## Truthy와 Falsly

- 불리언 타입으로 평가되어야 할 문맥에서 불리언 타입이 아닌 다른 타입이 암묵적 타입 변환을 통해 `true` 값과 `false` 값으로  평가되는 것을 말한다.
- 암묵적 타입 변환을 통해 `Truthy` 는 `true`로 변환되고,
- `Falsly` 는 `false`로 변환된다.

### Falsly으로 평가되는 값

- false
- undefind
- null
- 0
- -0
- ‘’
- NaN

### Truthy으로 평가되는 값

- 빈 배열 `[]`
- 빈 객체 `{}`
- 빈 함수 객체 `function() {}`
- 그 외 모든 것

# 09. 타입 변환과 단축 평가


자바스크립트의 모든 값은 타입이 있다.

- 개발자가 의도적으로 타입을 변경하는 것을 `명시적 타입 변환`  또는 `타입 캐스팅`이라고 불린다.
- 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되는 것을 `암묵적 타입 변환` 또는 `타입 강제 변환`이라고 불린다.
- 원시 타입의 값은 변경 불가능한 값이다.
- 타입 변환을 하면 기존 원시 값을 사용해 다른 타입의 새로운 원시 값을 생성하는 것이다.
- 암묵적 타입 변환을 지양하는게 좋다.
- 때로는 가독성을 높이기 위해서 암묵적 타입 변환을 사용하는 것도 좋다.

가장 중요한 것은 코드를 예측할 수 있어야 한다는 것이다.


## 암묵적 타입 변환


자바스크립트 엔진은 에러를 발생시키지 않도록 암묵적 타입 변환을 통해 사용한다. 이때 원시 타입 중 하나로 자동 변환해 평가한다.


### 문자열  타입으로 암묵적 타입 변환


#### (+) 연산자


피연산자 중 하나 이상이 문자열이면 문자열 타입으로 변환한다.


```javascript
// 숫자 타입 > 문자열 타입
10 + '' // "10" 문자열 타입 변환
-1 + '' // "-1"
NaN + '' // "NaN"

// 불리언 타입 > 문자열 타입
true + '' // "true"
false + '' // "false"

// null 타입 > 문자열 타입
null + '' // "null"

// undefined 타입 > 문자열 타입
undefined + '' // "undefined"

// 심벌 타입 > 문자열 타입
(Symbol()) + '' // 타입 에러 발생 

// 객체 타입 > 문자열 타입
({}) + '' // "[object Object]"
Math + '' // "[object Object]"
[] + '' // ""
[10, 20] + '' // "10, 20"
(function(){}) + '' // "function() {}"
```


#### 템플릿 리터럴 표현식 삽입


평가 결과를 문자열 타입으로 암묵적 변환한다.


```javascript
`1 + 1 = ${1 + 1}` // -> "1 + 1 = 2"
```


### 숫자 타입으로 암묵적 타입 변환


#### 산술 연산자

- **`(+) 단항 연산자`** **또는** **`(-) 단항 연산자`** **는** 숫자 타입으로 변환한 값을 생성해 반환한다.
- (+) 연산자 제외한 `이항 연산자`는 두 개의 피연자의 타입이 다르면, 숫자 타입으로 암묵적 타입 변환 한다.

### **불리언 타입으로 암묵적 타입 변환**

- 불리언 값으로 평가되야 할 문맥에 **불리언 타입이 아닌 다른 타입을 평가하는 경우** **`Truthy`** **와** **`Falsly`****로** 구분되고, **`true/false`****로 암묵적 변환**되어 평가한다.

## 명시적 타입 변환


표준 빌트인 생성자 함수(Stsring, Number, Boolean)를 `new 연산자` 없이 호출하는 방법과 빌트인 메서드를 사용하는 방법이 있다.


`new 연산자`를 함께 호출하면 해당하는 객체 타입이 반환된다.


### **문자열 타입으로 명시적 타입 변환**

- String 생성자 함수를 new 연산자 없이 호출하는 방법
- Object.prototype.toString 메서드를 사용하는 방법

### **숫자 타입으로 명시적 타입 변환**

- Number 생성자 함수를 new 연산자 없이 호출하는 방법
- paerInt, parseFloat 함수를 사용하는 방법(문자열만 숫자 타입으로 변환 가능)

### **불리언 타입으로 명시적 타입 변환**

- Boolean 생성자 함수를 new 연산자 없이 호출하는 방법
- (!) 부정 논리 연산자를 두 번 사용하는 방법

```javascript
// 부정 연산자는 무조건 불리언 값을 반환한다.
// 피연산자 값이 Truthy 라면 논리 부정으로 false
// 피연산자 값이 Falsly 라면 논리 부정으로 true
// 이를 이용해 논리 부정 연산자를 두 번 사용하면 
// Truthy라면 true, Falsly 라면 false 를 반환한다.
!15 // false
!!15 // true
```


## 단축 평가


단축 평가란 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것을 말한다. 


### **논리 연산자를 이용한 단축 평가**

- 논리 연산자의 평가 결과는 불리언 값이 아닐 수 있다.
- 논리 연산자 표현식은 2개의 피연산 중 어느 한쪽으로 평가된다.
- **불리언 타입으로 평가하는 문맥이 아닌** **상황**에서 논리 연산자 표현식은 피연산자를 타입 변환하지 않고 그대로 반환한다.

#### **첫 번째 Truthy를 찾는 OR 연산자**


```javascript
const val1 = '';
const val2 = '요기';
const val3 = '';

// 첫 번째 truly 피연산자를 찾아서 반환한다.
const result= val1 || val2 || val3;

console.log(result); // expected : '요기'
console.log(typeof result) // expected : string

// 만약 truthy가 존재하지 않으면, 마지막 피연산자 반환
console.log('' || 0 || null); // expected : null
```


#### **첫 번째 Falsly를 찾는 AND 연산자**


```javascript
const val1 = '';
const val2 = '요기';
const val3 = '';

// 첫 번째 falsly 피연산자를 찾아서 반환한다
const result= val1 && val2 && val3;

console.log(result); // expected : ''
console.log(typeof result) // expected : string

// 만약 falsly가 존재하지 않으면, 마지막 피연산자 반환
console.log('1' && '2' && '3'); // expected : 3

// 객체를 가리키기를 기대하는 변수가 null 또는 undefind 확인 후 프로퍼티 참조
var obj = null;

// 타입 에러를 발생시킨다.
console.log(obj.value); // TypeRror : Cannot read property 'value' of null
// 타입 에러를 발생시키지 않는다.
console.log(obj && obj.value); // expected : null
```


### **옵셔널 체이닝 연산자**

- 옵셔널 체이닝 연산자 `?.` 는 ES11에 도입되었다.
- 좌항의 피연산자가 `null` 또는 `undefind` 인 경우 `undefind` 를 반환한다.
- 그렇지 않으면 우항의 프로퍼티 참조를 이어간다.
- 옵셔널 체이닝은 연산자가 아니라 특별한 문법 구조체이다.

### **null 병합 연산자**

- null 병합 연산자 `??` 는 ES11에 도입되었다.
- 좌항의 피연산자가 `null` 또는 `undefind` 인 경우 **우항의 피연산자**를 반환한다.
- 그렇지 않으면 **좌항의 피연산자**를 반환한다.

> 💡 **OR 연산자와 null 병합 연산자 차이점**  
>   
> OR 연산자는 Falsly일 경우 평가 결과가 확정된다.  
> null 병합 연산자는 null, undefined 일 때만 평가 결과가 확정된다.

