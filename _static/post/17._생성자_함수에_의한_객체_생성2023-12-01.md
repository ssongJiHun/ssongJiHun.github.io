---
template : "post"
title : "17. 생성자 함수에 의한 객체 생성"
category : ""
tags : "DeepDive"
created: "2023-12-01"
---

# 17. 생성자 함수에 의한 객체 생성


객체는 객체 리터럴 이외에도 다양한 방법으로 생성할 수 있다.


**생성자 함수**란 `new 연산자`와 **함께 함수를 호출**하여 **객체(인스턴스)를 생성하는 함수**이다.
생성자 함수에 의해 **생성된 객체를 인스턴스**라 한다.


## 생성자 함수


### 객체 리터럴에 의한 객체 생성 방식의 문제점

- **객체 리터럴**에 의한 객체 생성 방식은 **하나의 객체만 생성**한다.
- 따라서 **동일한 프로퍼티를 갖는 객체 여러 개 생성**해야 하는 경우
- 매번 같은 프로퍼티를 기술해야 하기 때문에 **비효율적**이다.

### 생성자 함수에 의한 객체 생성 방식의 장점


**생성자 함수에 의한 객체 생성 방식**은 **프로퍼티 구조가 동일한 객체 여러 개**를 간편하게 생성할 수 있다.


```javascript
// 생성자 함수
function Circle(radius) {
	// 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다.
	this.radius = radius;
	this.getDiameter = function() {
		return 2 * this.radius;
	}
};

// 인스턴스 생성
const circle1 = new Circle(5);
const circle2 = new Circle(10);

console.log(circle1.getDiameter);
console.log(circle2.getDiameter);

const circle3 = Circle(15); // 일반 함수로 호출

// 일반 함수로서 호출된 Cricle은 반환문이 없음으로 암묵적으로 undefined를 반환한다.
console.log(circle3); // undefind 

// 일반 함수로 호출된 Circle 내의 this는 전역을 가리키기 때문에 전역 객체 프로퍼티를 생성하게된다.
console.log(radius); // 15
```


**일반 함수와 동일한 방법으로 생성자 함수를 정의**한다.

- `new연산자` 와 **함께 함수 호출**하면 해당 함수는 **생성자 함수로 동작**한다.
- `new 연산자`와 **함께 함수를 호출하지 않으면** 생성자 함수가 아니라 **일반 함수로 동작**한다.

### 생성자 함수의 역활


생성자 함수가 **인스턴스를 생성**하는 것은 **필수**, **초기화**는 **옵션**이다.

- **프로퍼티가 동일**한 **인스턴스**를 **생성**하기 위한 템플릿(클래스)로 동작하여 **인스턴스**를 생성하는 것
- **생성된 인스턴스를 초기화**(인스턴스 프로퍼티 추가 및 초기 값 할당) 하는 것

### 생성자 함수의 인스턴스 생성 과정


`new 연산자` 와 함께 함수를 생성자 함수로 호출하면 자바스크립트 엔진은 **암묵적인 처리**를 통해 **인스턴스를 생성**하고 **반환**한다.


다음과 같은 가정을 거쳐 암묵적 인스턴스 생성, 초기화, 인스턴스를 반환한다.

1. **인스턴스 생성과  this 바인딩**
	- 암묵적으로 빈 객체 생성(반환할 인스턴스)
	- 인스턴스는 this에 바인딩 된다.
	- 런타임 이전 시점
2. **인스턴스 초기화**
	- 생성자 함수에 기술되어 있는 코드를 한 줄씩 실행
	- this에 바인딩되어 있는 인스턴스 초기화
	- 개발자가 코드를 통해 기술
3. **인스턴스 반환**
	- 인스턴스가 바인딩된 this가 암묵적으로 반환

만약 this가 아닌 **다른 객체를 명시적으로 반환**하면 this가 반환되지 못하고 return 문에 **명시된 객체가 반환**된다.


```javascript
function Circle(radius) {
	// 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다.
	this.radius = radius;
	return {};
};

const circle new Circle(14);
console.log(circle); // {}
```


하지만 객체가 아닌 원시 값을 반환하면 원시 값은 무시되고 암묵적으로 this가 반환 된다.


```javascript
function Circle(radius) {
	// 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다.
	this.radius = radius;
	return 999;
};

const circle new Circle(14);
console.log(circle); // Circle {radius: 14}
```


### constructor와 non-constructor의 구분


자바스크립트 엔진은 **함수 정의 방식**에 따라 `constructor`와 `non-constructor`로 구분한다.

- **`constructor`**  함수 선언문, 함수 표현식, 클래스로 정의된 함수는 **내부 메서드 [[Construct]]가 있다**.
- `non-constructo`**`r`**  메서드(ES6 축약 표현), 화살표 함수로 정의된 함수는 **내부 메서드 [[Construct]]가 없다**.

ECMAScript 사양에서 메서드로 인정받는 범위가 일반적인 의미의 메서드보다 좁다.

- 일반적으로 함수를 프로퍼티 값으로 사용하면 메서드로 통칭
- ECMAScript 사양에서는 **메서드 축약 표현**만을 의미

```javascript
// 함수 선언문 : 생성자 함수로 호출 가능
function Fnc1() { } // [[Call]], [[Construct]] > constructor
console.log(new Fnc1()); // Fnc1 {}

// 함수 표현식 : 생성자 함수로 호출 가능
const Fnc2 = function() {} // [[Call]], [[Construct]] > constructor
console.log(new Fnc2()); // Fnc2 {}

// 일반적인 통칭하는 메서드  : 생성자 함수로 호출 가능
const Fnc3 = {
	method : function() {
	}
}
console.log(new Fnc3.method()); // TypeError: Fnc3 is not a constructor

// ECMAScript 사양 메서드  : 생성자 함수로 호출 불가능
const Fnc4 = {
	method () {
	}
}
console.log(new Fnc4()); // TypeError: Fnc4 is not a constructor

// 화살표 함수  : 생성자 함수로 호출 불가능
const Fnc5 = () => {}
console.log(new Fnc5()); // TypeError: Fnc5 is not a constructor
```


### 내부 메서드 [[Call]]과 [[Construct]]

- **일반 객체**는 **호출할 수 없지만** 함수는 호출 할 수 있다.
- **함수 객체**는 **일반 객체**가 가지고 있는 **내부 슬롯**과 **내부 메서드**를 모두 가진다.
- 함수 객체는  **[**[Environment]], [[FormalParameters]] 등의 내부 슬롯과
- `[[Call]]`. `[[Construct]]` 같은 **내부 메서드**를 추가로 가지고 있다
- **객체를 호출**하기 위해서는 **내부 메서드** **`[[Call]]`**을  갖고 있어야 한다.
- 따라서 **함수 객체**는 내부 메서드 `[[Call]]`를 가지고, **`callable`**이다.
- 함수를 **일반 함수로 호출**하면 **내부 메서드** **`[[Call]]`**를 호출하고
- **`ne`**`w 연산자`**와 함께 생성자 함수**로 **호출**하면 내부 메서드  **`[[Construct]]`**가 호출된다**.**
- 내부 메서드 `[[Construct]]` 를 가지면 `constructor`
- 내부 메서드 `[[Construct]]` 가 없다면 `non-constructor` 라고 부른다.
- `constructor` 는 **생성자 함수로 호출**할 수 있는 함수를 의미한다.

### new 연산자


일반 함수와 생성자 함수에 형식은 동일하다. 호출하는 방식에 따라 구분된다.

- `new 연산자` 와 함께 함수를 호출하면 해당 함수는 **생성자 함수**로 **동작**한다.
- 내부 메서드 `[[Construct]]` 를 호출한다.
- 단, 호출하는 함수가 `constructor` 이여야 한다.

### new.target


생성자 함수가 `new 연산자` 없이 호출되는 것을 방지하기 위해 파스칼 케이스를 컨벤션을 사용한다.

- `new.target` 은 `constructor` 인 모든 함수 내부에서 사용되며, 메타 프로퍼티라고 부른다.
- [`new.target`](http://new.target/) 을 사용하면 `new 연산자` 와 함께 생성자 함수로서 호출되었는지 확인 할 수 있다.
- 일반 함수로 호출하면 [`new.target`](http://new.target/)는 `undefind` 다
- ES6에서 도입된 최신 문법으로 IE에서는 지원하지 않는다.

[`new.target`](http://new.target/) 을 활용해 일반 함수로 호출되었지만 생성자 함수로 호출하게 할 수 있다.


```javascript
// 생성자 함수
function Circle(radius) {
	if(!new.target)
		return new Circle(radius);
}
```


IE에서 지원하기 위해서는 스코프 세이프 생성자 패턴을 사용하면 된다.


```javascript
// 스코프 세이프 생성자
function Circle(radius) {
	if(!(this instanceof  Circle)) {
		return new Circle(radius);
	}
}
```


대부분의 빌트인 생성자 함수는 `new 연산자`와 함께 호출되었는지 확인 후 적절한 값을 반환한다.


String, Number, Boolean 생성자 함수는 `new 연산자` 와 함께 호출했을 때 해당하는 객체를 생성하여 반환하지만,
일반 함수로 호출하면 해당하는 값을 반환한다.

