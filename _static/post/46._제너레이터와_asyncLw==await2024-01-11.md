---
template : "post"
title : "46. 제너레이터와 async/await"
category : ""
tags : "DeepDive"
created: "2024-01-11"
---

# 46. 제너레이터와 async/await


> ES6에서 도입된 제너레이터는 코드 블록의 실행을 일시 중지했다가 필요한 시점에 재개할 수 있는 특수한 함수다.


### **제너레이터 함수는 함수 호출자에게 함수 실행의 제어권을 양도할 수 있다.**

- 제너레이터 함수는 함수 호출자가 함수 실행을 일시 중지시키거나 재개할 수 있다.
- 즉, 함수의 제어권을 독점하는 것이 아니라 함수 호출자에게 양도(yield)할 수 있다.

### 제너레이터 함수는 함수 호출자와 함수의 상태를 주고 받을 수 있다.

- 제너레이터 함수는 함수 호출자와 양방향으로 함수의 상태를 주고 받을 수 있다.
- 즉, 함수 호출자에게 상태를 전달할 수 있고 함수 호출자로부터 상태를 전달받을 수 있다,

### 제너레이터 함수를 호출하면 제너레이터 객체를 반환한다.

- 제너레이터 함수를 호출하면 함수 코드를 실행하는 것이 아니라
- 이터러블이면서 동시에 이터레이터인 제너레이터 객체를 반환한다.

## 제너레이터 함수 정의

- `function*` 키워드로 선언한다.
- 반드시 하나 이상의 `yield` 표현식을 포함한다.
- 애스터리스크`*` 위치는 `function`키워드와 함수 이름 사이라면 어디든지 상관없다.
- `function`키워드 바로 뒤에 붙이는 것을 권장한다.
- 화살표 함수로 정의할 수 없다.
- `new` 연산자와 함께 사용할 수 없다.

```javascript
// 제너레이터 함수 선언문
function* genDecFunc() {	yield 1; }

// 제너레이터 함수 표현식
const genExpFunc = function* () { yield 1; }

// 제너레이터 메서드
const obj = { 
	* genObjMedthod() { yield 1; } 
};

// 제너레이터 클래스 메서드
class MyClass {
	* genClsMethod() { yield 1; }
}

// 애스터리스크 위치 무관
function* genFunc() { yield 1; }
function * genFunc() { yield 1; }
function *genFunc() { yield 1; }
```


## 제너레이터 객체

- 제너레이터 함수를 호출하면 제너레이터 객체를 생성해 반환한다.
- 제너레이터 객체는 이터러블이면서 동시에 이터레이터다.
- 제너레이터 객체는 이터레이터에 없는 `return`, `throw` 메서드를 갖는다.
- next 메서드를 호출하면 제너레이터 함수의 yield 표현식까지 코드 블록을 실행하고
- `value` 프로퍼티 값이 `yield`된 값이 되고
- `done` 프로퍼티 값이 `false`을 갖는 이터레이터 리절트 객체를 반환한다.
- return 메서드를 호출하면
- `value` 프로퍼티 값이 인수로 전달 받은 값이 되고,
- `done` 프로퍼티 값이 `true` 을  갖는 이터레이터 리절트 객체를 반환한다.
- throw 메서드를 호출하면 인수로 전달받은 에러를 발생시키고,
- `value` 프로퍼티 값이 `undefined` 되고,
- `done` 프로퍼티 값이 `true`을 갖는 리터레이터 리절트 객체를 반환한다.

```javascript
function* genFunc() {
	try {
		yield 1;
		yield 2;
		yield 3:
	} catch (e) {
		console.error(e);
	}
}

const generator = genFunc(); // 이터러블이면서 이터레이터
console.log(generator.next()); // { value: 1, done: false }
console.log(generator.return('end!')); // { value: 'end!', done: flase }
console.log(generator.throw('Error!')); // { value: 'Error!', done: true }
```


## 제너레이터의 일시 중지와 재개

- `yield` 키워드는 제너레이터 함수의 실행을 일시 중지 시키거나 키워드 뒤에 오는 표현식의 평가 결과를 함수 호출자에게 반환한다.
- 제너레이터 객체의 `next` 메서드를 호출하면 `yield` 표현식까지 실행되고 일시 중지된다
- 이때 함수의 제어권이 호출자에게 양도 된다,
- 제너레이터 `next` 메서드는 value, done 프로퍼티를 갖는 이터레이터 리절트 객체를 반환한다.
- 이터레이터 리절트 객체의 value 프로퍼티에는  `yield된 값`(yield 키워드 위에 오는 값)이 할당되고
- `done` 프로퍼티에는 제너레이터 함수가 끝까지 실행되었는지를 나타내는 불리언값이 할당된다.
- 이터레이터 `next` 메서드와는 달리 제너레이터 객체의 `next` 메서드는 인수를 전달할 수 있다.
- 제너레이트 `next` 메서드에 전달한 인수는 제너레이터 함수의 `yield`  표현식을 할당받는 변수에 할당된다.
- 할당받는 변수에 yield된 값이 할당되는게 아니다.

```javascript
function *genFunc() {
	const x = yield 1; // x에는 yield된 값이이 할당되는 것이 아니다.

   // 두 번째 next 호출할 때 전달한 인수가 x에 할당된다.
  console.log('x', x); // 11
	const y = yield x + 10;

   // 세 번째 next 호출할 때 전달한 인수가 y에 할당된다.
  console.log('y', y); // 2
	return x + y;
}

const generator = genFunc();

let res = generator.next();
console.log(res); // 첫 번째 yield된 값 : { value: 1, done: false }

res = generator.next(11);
console.log(res); // 두번 째 yield 된 값 : { value: 21, done: false }

res = generator.next(22)
console.log(res); // 제너레이터 함수 반환 값 : { value: 33, done: true }
```


## 제너레이터의 활용


### 이터러블의 구현

- 제너레이터 함수를 사용하면 이터레이션 프로토콜을 준수해 이터러블을 생성하면 이터러블을 생성하는 방식보다 간단히 구현할 수 있다.

```javascript
// 무한 이터러블을 생성하는 함수
const infiniteFibonacci = (function () {
  let [pre, cur] = [0, 1];

  // 이터러블이자 이터레이터 프로토콜
  return {
    [Symbol.iterator]() {
      return this;
    },
    next() {
      [pre, cur] = [cur, pre + cur];
      return { value: cur };
    }

  }
}());

// 무한 이터러블을 생성하는 제너레이터 함수
const infiniteFibonacci = (function () {
  let [pre, cur] = [0, 1];

  while (true) {
    [pre, cur] = [cur, pre + cur];
    yield cur;
  }
}());
```


### 비동기 처리


```javascript
const async = (generatorFunc) => {
  const generator = generatorFunc();

  const onResolveed = arg => {
    const result = generator.next(arg);

    return result.done ? result.value : result.value.then(res => onResolveed(res));
  };

  return onResolveed;
}


(
  async(function* () {
    const url = '';

    const response = yield fetch(url);
    const todo = yield response.json();
    console.log(todo);
  })() // 반환받은 onResolveed 즉시 실행
);
```


## async/await

- ES8에서 도입되었다.
- async/await는 프로미스를 기반으로 동작한다.
- then/catch/finally 후속 처리 메서드에 콜백 함수를 전달할 필요가 없다.
- 프로미스를 동기 처리 처럼 사용할 수 있다.

### async 함수

- 언제나 프로미스를 반환한다.
- 명시적으로 프로미스를 반환하지 않더라도 async 함수는 암묵적으로 resolve하는 프로미스를 반환한다.

### await 키워드

- async 함수 내부에서 사용해야한다.
- 프로미스가 settld 상태가 될 때가지 대시하다가 settled 상태가 되면 resolve한 **처리 결과**를 반환한다.
- 반드시 프로미스 앞에서 용해야한다.
- 여러개의 프로미스에 await 키워드를 사용하면 대기해서 순차적으로 처리된다.

```javascript
(async function() {
  // 프로미스가 settled 상태가 되면 프로미스가 resolve한 처리 결과가 res 변수에 할당된다.
	const res = await new Promise(resolve => setTimeout(()=> resolve(1), 1000));
}());
```


### 에러처리

- 에러는 호출자 방향으로 전파된다.
- 하지만 비동기 함수의 콜백 함수를 호출한 것은 비동기 함수가 아니다.
- 이벤트 루프에 콜 스택이 비면 대기 중이던 비동기 함수를 콜 스택에 푸쉬하여 실행하기 떄문이다.
- async/await 에서 에러처리는 try…catch를 사용할 수 있다.
- 콜프로미스를 반환하는 비동기 함수는 명시적으로 호출할 수 있기 때문에 호출자가 명확하다.
- async 함수 내에서 catch 문을 사용해서 에러 처리를 하지 않으면 async 함수는 발생한 에러를 reject하는 프로미스를 반환한다.
- 따라서 asnc 함수를 호출하고 Promise.prototype.catch 후속 처리 메서드를 사용해 에러를 캐리할 수도 있다.
