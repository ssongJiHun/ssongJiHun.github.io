---
template : "post"
title : "35. 스프레드 문법"
category : ""
tags : "DeepDive"
created: "2023-12-28"
---

# 35. 스프레드 문법

- ES6에 도입되었다.
- 하나로 뭉쳐 있는 여러 값들의 집합을 펼쳐 개별적인 값들의 목록으로 만든다.
- 스프레드 문법을 사용할 수 있는 대상은 이터러블에 한정된다.
- 값을 생성하는 연산자가 아니다.

```javascript
const list = ...[1, 2, 3]; // 문법 오류
```


## 함수 호출문의 인수 목록에서 사용하는 경우

- 스프레드 문법은 간결하고 가독성이 좋다.
- 스프레드 문법은 이터러블을 펼쳐 각각의 인수로 전달한다.
- Rest 피라미터는 인수들의 목록을 배열로 전달 받는다.

```javascript
// ES5
var arr1 = [1, 2, 3];
console.log(Math.max.apply(null, arr1)); // 3

// ES6
const arr2 = [1, 2, 3];
console.log(Math.max(...arr2); // 3

// Rest 피라미터와 다르다.
function foo(...rest) {
	console.log(rest); // [2, 2, 2]
}
foo(2, 2, 2);

// 함수 호출문의 인수 목록 스프레드 문법
function boo(a, b, c) {
	console.log(a, b, c); // 2 2 2
}
boo(...[2, 2, 2]);
```


## 배열 리터럴 내부에서 사용하는 경우


### concate


```javascript
var arr1 = [1, 2, 3].concat([4, 5]);
console.log(arr1); // [ 1, 2, 3, 4, 5 ]

// ES6 spread
const arr2 = [...[1, 2, 3], ...[4, 5]];
console.log(arr2); // [ 1, 2, 3, 4, 5 ]
```


### splice


```javascript
var arr1 = [1, 4];
var arr2 = [2, 3];
Array.prototype.splice.apply(arr1, [1, 0].concat(arr2));

// ES6 spread
const arr1 = [1, 4];
const arr2 = [2, 3];

// [start, deleteCnt]
arr1.splice(1, 0, ...arr2); 
```


### 배열 복사


```javascript
var origin = [1, 2];
var copy = origin.slice();

// ES6 spread
const origin = [1, 2];
const copy = [...origin];
```


### 이터러블을 배열로 변환


```javascript
function sum() {
	// arguments는 이터러블이면서 유사 배열 객체다.
	return [...arguments];
}

function sum(...args) {
	// Rest 피라미터는 배열이다.
	return args;
}

// Array.from 메서드는 유사 배열 객체 또는 이터러블을 인수로 전달받아 배열로 변환해 반환한다.
const arrayLike = {
	0: 1,
	1: 2,
	2: 3,
	length : 3
};

Array.from(arrayLike);
console.log([...arrayLike]); // 유사 배열 객체는 스프레드 문법의 대상이 될 수 없다.
```


## 객체리터럴 내부에서 사용하는 경우

- 2021년 1월 TC39 프로세스의 stage4(Finished) 단계에 스프레드 프로퍼티가 제안되어 있다.
- 스프레드 문법의 대상은 이터러블이여야 하지만 스프레드 프로퍼티 제안을 사용하면 프로퍼티 목록도 사용할 수 있다.

```javascript
// 스프레드 프로퍼티
// 얕은 복사
const obj = { x: 1, y: 2 };
const copy = { ...obj }; // { x: 1, y: 2 }

// 객체 병합
const merged1 = { x: 1, y: 2, ...{ a: 3, b: 4 } }; // { x: 1, y: 2, a: 3, b: 4 }

// 프로퍼티가 중복되는 경우 뒤에 위치한 프로퍼티가 우선권을 가진다.
const merged2 = { ...{ x: 1, y: 2 }, ...{ y: 10, z: 3 } }; // { x: 1, y: 10, z: 3 }

// 특정 프로퍼티 변경
const changed = { ...{ x: 1, y: 2 }, y: 100 }; // { x: 1, y: 100 }

// 프로퍼티 추가
const added = { ...{ x: 1, y: 2 }, z: 0 }; // { x: 1, y: 2, z: 0 }
```

