---
template : "post"
title : "함수형 자바스크립트를 위한 기초"
category : ""
tags : "함수형 프로그래밍"
created: "2023-10-25"
---

자바스크립트의 거의 모든 값은 객체로 이뤄줘 있고, 함수 또한 객체이다.


## 일급 객체


자바스크립트 객체는 일급 객체이다. “일급”은 값으로 다룰 수 있다는 의미로 다음과 같은 조건을 만족해야한다.

- 변수에 담을 수 있다.
- 함수나 메서드의 인자로 넘길 수 있다.
- 함수나 메서드에서 리턴할 수 있다.

## 일급 함수


자바스크립트에서 **함수는 일급 객체이자 일급 함수**이다. 일급 함수의 조건은 일급 객체의 조건을 만족하는 동시에 추가적인 조건이 더 필요하다.

- 아무 때나(런타임에서도) 선인이 가능하다.
- 익명으로 선언할 수 있다.
- 익명으로 선언한 함수도 함수나 메서드의 인자로 넘길 수 있다.

자바스크립트의 함수는 위 조건을 모두 만족하는 일급 함수이다.


## 고차 함수


고차 함수란 **함수를 다루는 함수를 말한다.** 함수를 다룬다는 것은 다음과 같다.

- 함수를 인자로 받아 대신 실행하는 함수
- 함수를 리턴하는 함수
- 함수를 인자로 받아서 또 다른 함수를 리턴하는 함수

```javascript
// 함수를 인자로 받아 대신 샐행하는 함수 = 고차함수
// 매개변수 fnc 함수를 다룬다.
function callWith10(val, fnc) {
	return fnc(10, val);
}

function add(a, b) { return a + b}
function sub(a, b) { return a - b}

callWith10(5, add); // 15
callWith10(5, sub); // 5
```


```javascript
// 함수를 리턴하는 함수 = 고차함수
// 함수 내에서 함수를 정의해 반환한다. 함수를 다룬다.
function constant(val) {
	return function() {
		return val;
	}
}

var alway10 = constant(10);
alway10() // 10
```


```javascript
// 함수를 인자를 받아 대신 실행하고 다른 함수를 리턴  = 고차함수
// 위 두 개의 예시를 조합 = 함수를 다루는 함수
function callWith(val1) { // 함수를 리턴하는 함수
	return function (val2, fnc) { // 함수를 인자로 받아서 대신 실행하는 함수
		return fnc(val1, val2);
	}
}

var callWith10 = callWith(10);

callWith10(20, function(a, b) {
	return a + b;
}); 	
```


## 콜백 함수라 잘못 불리는 보조 함수


### 콜백 함수


콜백 함수를 받아 자신이 해야 할 일을 모두 끝 낸 후에 결과를 되돌려 주는 함수도 고차 함수다.
콜백 함수를 통해 다시 원래 위치로 돌아오기 위해 사용되는 패턴이다.


**콜백 패턴**은 끝이 나면 컨텍스트를 다시 돌려주는 단순한 협럽 로직을 가지고 **이러한 경우에만 “콜백 함수”**라고 부르는게 맞다고 생각한다. 


### 보조 함수


`button.click(function() {})` 에서  익명 함수는 **“이벤트 리스너”**


`[].map(function() {})` 에서 익명 함수는 **“iteratee”**


`[].filter(function () {})` 에서 익명 함수는 **“predicate”**


이처럼 함수가 고차 함수에서 쓰이는 **역활의 이름**으로 불러주면 된다.


모든 익명 함수는 콜백 함수가 아니다. 다양한 로직을 가진 각기 다른 고차 함수들을 만들 수 있고, 그 함수에서 사용될 보조 함수에게도 역활에 가장 맞는 이름이 있는 것이다.


## 클로저


자바스크립트의 모든 함수는 글로벌 스코프에 선언되거나 함수 안에서 선언된다.
**모든 함수는 상위 스코프**를 가지며 모든 함수는 **자신이 정의되는 순간**의(정의되는 곳의) **실행 컨텍스트** 안에 있다.


**클로저**는 자바스크립트의 모든 함수는 어느 곳에서 생성하든 어떤 방법으로 생성하든 **자신이 생성될 때의 환경**을 **기억**하는 것이다.



모든 변수는 실행 컨텍스트가 끝난 후 가비지 컬렉션 대상이 된다.  **함수가 외부 스코프의 변수를 참조하고 있지 않으면 가비지 컬렉션 대상**이 된다. 
즉, 모든 함수가 클로저가 아니다.


**클로저**는 자신이 **생성될 때의 스코프**에서 알 수 있었던 **변수 중 언젠가 자신이 실행될 때 사용할 변수들만** 기억하여 유지시키는 함수이다. 클로저가 기억하는 변수의 값은 언제든지 남이나 지신의 의해 **변경될 수 있다**.


```javascript
// 예제 1 : 클로저가 아닌 경우
function parent() {
	var a = 10; //  변수를 참조하고 있지 않음.
	function children() {
	}
}

// 예제 2 : 잠깐동안만 클로저인 경우
function f4() {
	var a = 10;
	function f5() { // 클로저 생성
		return a + 1; 
	}
	return f5(); // 함수 실행 결과를 반환.
}

// 예제 4 : 클로저인 경우
function f6() {
	var a = 10;
	function f7() {
		return a + 1; // 상위 스코프의 a를 기억하고 있다.
	}
	return f7; // 함수 객체를 반환
}
var f8 = f6(); // f8은 f6의 반환 값인 f7을 참조하고 있다.
console.log(f8())
```


### **런타임 환경 차이**

- Node 환경에서는 독립적인 스코프를 가진다.
- Brower 환경에서는 하나의 전역 스코프를 공유한다.

```javascript
var a = 10;
var b = 20;
function f1() {
	return a +b;
}
f1();
```


위의 코드는 `Node` 환경에서는 클로저이고, `Brower` 환경에서는 클로저가 아니다.


### 클로저의 실용 사례


클로저가 강력하고 실용적인 상황이다.

- 이전 상황을 나중에 일어날 상황과 이어 나갈 때
- 함수로 함수를 만들거나 부분 적용을 할 때

클로저의 흔한 실수부터 알아보자.


```javascript
var btns = [];
for (var i = 0; i < users.length; i++) {
    var user = users[i];
    var li = $('<li>').append(
        $('<button>').text(user.name).click(function () { 
            alert(user.id); // 해당 클로저는 같은 컨텍스트를 공유한다.
        })
    );
    btns.push(li);
}
$('#user-list').append(btns);
```


실행된 화면의 모든 버튼들이 배열 요소의 마지막 원소 유저 이름를 참조하고 있다.
이는 `var` 키워드는 블록 레벨 스코프를 허용하지 않기 때문에 변수 “i”는 전역 변수이다.


해결하기 위해서는 `let` 키워드를 사용하는 것도 방법이지만, 함수를 사용해 새로운 컨텍스트를 생성한다면 안전하게 해결할 수 있을 것이다.


```javascript
$('#user-list').append(
    users.map(function (user) {
				// 익명 함수를 통해 각각의 새로운 컨텍스트를 생성한다.
        return $('<li>').append(
            $('<button>').text(user.name).click(function () 
								// 해당 클로저는 각각의 상위 스코프의 실행 컨텍스트이다.
                alert(user.id)
            })
        )
    })
);
```


### 클로저를 많이 사용하라!


자바스크립트에서 클로저는 절차지향 프로그래밍, 객체지향 프로그래밍, 함수형 프로그래밍 모두를 지탱하는 매우 중요한 기능이자 개념이다.


클로저는 메모리 누수 같은 위험성을 가지고 있다. 그러나 메모리 누수 가 일어나지 않는 로직 설계법을 더욱 깨우치게 되고, 클로저를 활용한 아름다운 패턴들도 자연스럽게 알게 될 것이다.

