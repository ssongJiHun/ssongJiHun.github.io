---
template : "post"
title : "09. 타입 변환과 단축 평가 (08장 제어문 포함)"
category : ""
tags : "DeepDive"
created: "2023-11-17"
---

0“모던 자바 스크립트 Deep Dive “ 학습 내용을 정리한 글입니다.


**“8장 조건 제어문은 간단 정리했다.”
참고 >** [https://ko.javascript.info/optional-chaining](https://ko.javascript.info/optional-chaining)


---


> **조건문**은 주어진 조건식의 평가 결과에 따라 코드 블록의 실행을 결정한다.  
> 1. `if…else` 문은 **불리언 값**으로 평가 한다.  
> 2. `switch` 문은 **문자열이나 숫자 값**으로 평가하는 경우가 많다..  
> 3. `for` `while` 문(반복문)은 **불리언 값**으로 평가하고 거짓이 될 때까지 코드 블록을 반복한다.


## Turthy와 Falsly


**불리언 타입으로 평가되야 할 문맥**(조건문, 삼항 연산자, 제어문)에서 자바스크립트 엔진은 **불리언 타입이 아닌 값의 평가 결과를 Truthy**와 **Falsly** 로 구분된다.


**암묵적 타입 변환**을 통해서 **Truthy**는 **true**로 **Falsly**는 **false** 로 변환된다.


다음은 Falsy 값이다. `false` `undefined` `null` `0` `-0` `''` `NaN`


```javascript
var str = '';

// 불리언 타입으로 평가되야할 문맥(조건문 또는 제어문)에 불리언 타입이 아닌 다른 타입인 경우.
// 1. Truthy 와 Falsly 로 구분한다.
// 2. true/false로 암묵적 타입 변환한다.
if(str) { 
					
}
```


자바스크립트의 **모든 값은 타입**이 있다. 표현식에서 타입을 변환하는 방법은 두 가지가 있다.

1. **개발자가 의도적**으로 타입을 변경하는 것을 **명시적 타입** 변환 또는 **타입 캐스팅**이라고 불린다.
2. 자바스크립트 **엔진에 의해** 암묵적으로 타입이 자동 변환되는 것을 **암묵적 타입 변환** 또는 **타입 강제 변환**이라고 불린다.

참조 타입의 값이 아닌 원**시 타입의 값은 변경 불가능한 값**이므로 변경할 수 없다.
타입 변환이란 기존 원시 값을 사용해 다른 타입의 **새로운 원시 값을 생성**하는 것이다.


만약 타입 변환 경과를 예측하지 못하거나 예측이 결과와 일치하지 않는다면 오류를 생산할 가능성은 높다.
이를 방지하기 위해서 **암묵적 타입 변환을 사용을 지양**하는게 좋지만 때로는 **가독성**을 높이기 위해서 암묵적 타입 변환을 사용하는 것이 더 좋을 수도 있다.


가장 중요한 것은 코드를 예측할 수 있어야 한다는 것이다.


## 암묵적 타입 변환


자바스크립트는 가급적 에러를 발생시키지 않도록 암묵적 타입 변환을 통해 사용한다. **[문자열, 숫자 ,불리언과 같은 원시 타입]** 중 하나로 자동 변환해 평가한다.


먼저 정리했던 **“7장 연산자”의 특성을 이용**함으로 다시 한번 보자.


### **문자열 타입으로 암묵적 타입 변환**

- `문자열 연결 연산자` 를 사용하여 암묵적으로 변환하는 방법.  
피연산자 중 하나 이상이 문자열이면 문자열 타입으로 암묵적 변환.

```javascript
// 숫자 타입 > 문자열 타입
10 + '' // "10" 문자열 타입 변환
-1 + '' // "-1"
NaN + '' // "NaN"

// 불리언 타입 > 문자열 타입
true + '' // "true"
false + '' // "false"

// null 타입 > 문자열 타입
null + '' // "null"

// undefined 타입 > 문자열 타입
undefined + '' // "undefined"

// 심벌 타입 > 문자열 타입
(Symbol()) + '' // 타입 에러 발생 

// 객체 타입 > 문자열 타입
({}) + '' // "[object Object]"
Math + '' // "[object Object]"
[] + '' // ""
[10, 20] + '' // "10, 20"
(function(){}) + '' // "function() {}"
```

- `템플릿 리터럴의 표현식 삽입` 으로 암묵적으로 변환하는 방법

### **숫자 타입으로 암묵적 타입 변환**

- `산술 연산자` 는 새로운 숫자를 생성하는 것이다. 암묵적으로 숫자 타입으로 변환해 연산한다.
- `(+)단향 연산자` `(*)단항 연산자`를 사용하는 방법

### **불리언 타입으로 암묵적 타입 변환**

- 불리언 값으로 평가되야 할 문맥에 **불리언 타입이 아닌 다른 타입을 평가하는 경우 
Truthy 와 Falsly로** 구분되고, **true/false로 암묵적 변환**되어 평가한다.

## 명시적 타입 변환


표준 빌트인 생성자 함수(Stsring, Number, Boolean)를 new 연산자 없이 호출하는 방법과 빌트인 메서드를 사용하는 방법이 있다.


new 연산자를 함께 호출하면 해당하는 객체 타입이 반환된다.


### **문자열 타입으로 암묵적 타입 변환**

- String 생성자 함수를 new 연산자 없이 호출하는 방법
- Object.prototype.toString 메서드를 사용하는 방법

### **숫자 타입으로 암묵적 타입 변환**

- Number 생성자 함수를 new 연산자 없이 호출하는 방법
- paerInt, parseFloat 함수를 사용하는 방법(문자열만 숫자 타입으로 변환 가능)

### **불리언 타입으로 암묵적 타입 변환**

- Boolean 생성자 함수를 new 연산자 없이 호출하는 방법
- (!) 부정 논리 연산자를 두 번 사용하는 방법

```javascript
// 부정 연산자는 무조건 불리언 값을 반환한다.
// 피연산자 값이 Truthy 라면 논리 부정으로 false
// 피연산자 값이 Falsly 라면 논리 부정으로 true
// 이를 이용해 논리 부정 연산자를 두 번 사용하면 
// Truthy라면 true, Falsly 라면 false 를 반환한다.
!15 // false
!!15 // true
```


## 단축 평가


단축 평가란 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것을 말한다. 


### **논리 연산자를 이용한 단축 평가**


논리 연산의 결과를 결정하는 피연산자 타입 **변환하지 않고 그대로 반환**한다. 
**불리언 타입으로 평가하는 조건식이 아닌** **상황**에서 논리 연산자는 **추가적인 기능**을 제공한다.

- **첫 번째 Truthy를 찾는 OR 연산자**

```javascript
const val1 = '';
const val2 = '요기';
const val3 = '';

// 첫 번째 truly 피연산자를 찾아서 반환한다.
const result= val1 || val2 || val3;

console.log(result); // expected : '요기'
console.log(typeof result) // expected : string

// 만약 truthy가 존재하지 않으면, 마지막 피연산자 반환
console.log('' || 0 || null); // expected : null
```

- **첫 번째 Falsly를 찾는 AND 연산자**

```javascript
const val1 = '';
const val2 = '요기';
const val3 = '';

// 첫 번째 falsly 피연산자를 찾아서 반환한다
const result= val1 && val2 && val3;

console.log(result); // expected : ''
console.log(typeof result) // expected : string

// 만약 falsly가 존재하지 않으면, 마지막 피연산자 반환
console.log('1' && '2' && '3'); // expected : 3
```


### **옵셔널 체이닝 연산자를 이용한 단축 평가**


ES11에서 도립된 옵셔널 체이닝 연산자 `?.` 는 좌항의 피연산자가 null 또는 undefined인 경우 undefind를 반환하고, 그렇지 않으면 **우항의 프로퍼티 참조**를 이어간다.
옵셔널 체이닝은 연산자가 아니라 특별한 문법 구조체 이다.

⚠ 옵셔널 체이닝에는 몇 가지 주의사항이 존재한다.

- `?.`  우항의 피연산자는 존재하지 않아도 괜찮은 대상에만 사용해야 한다.
- 좌항의 피연산자는 꼭 선언되어있어야 한다.

꼭 값이 있어야 하는 하는데 없는 경우 옵셔널 체이닝을 사용한다면 에러를 쉽게 찾을 수 없다.


**옵셔널 체이닝을 활용한 메서드 호출**


```javascript
const user1 = {
	admin : function() {
		return '관리자 입니다.';
	}
}

const user2 = {};

console.log(user1.admin?.()); // expected : 관리자 입니다.
console.log(user2.admin?.()); // expected : 
```


### **null 병합 연산자를 이용한 단축 평가**


ES11에서 도입된 null 병합 연산자 `??` 는 **좌항의 피연산자가 null 또는 undefined 인 경우** 우항의 피연산자를 반환하고 그렇지 않으면 좌항의 피연산자를 반환한다. 


```javascript
const name = null ?? 'defaultName';
```


## **OR 연산자와 null 병합 연산자 차이점**


```javascript
// OR 연산자는 Falsly일 경우 평가 결과가 확정된다.

const name1 = null || 'defaultName'; // 'defaultName'
const name2 = '' || 'defaultName';  // 'defaultName'

// null 병합 연산자는 null, undefined 일 때만 평가 결과가 확정된다.
const name3 = null ?? 'defaultName'; // 'defaultName'
const name4 = '' ?? 'defaultName';  // ''
```

